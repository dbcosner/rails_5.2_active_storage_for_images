# Saving images using Active Storage in Rails 5.2

Part of the work I did in the process of building a blog component for my [personal home page](https://drewcosner.com). (Ongoing as of writing this README.)

I wanted to be able to upload any number of images to use in any given blog post. Active Storage is now the Rails Way.

I used the Rails Edge documentation, and the information here: https://phase2online.com/blog/2018/10/03/easily-upload-files-with-active-storage-in-rails-5-2/

Installation is as simple as:

```
rails active_storage:install
rails db:migrate
```

### The Model

``app/models/blog_post.rb``

As usual, Rails makes things simple:

```ruby
class BlogPost < ApplicationRecord
  has_many_attached :images
end
```

### The Controller

``app/controllers/blog_posts_controller.rb``

To save the post, images and all, the only change I had to make to the file generated by the ``rails g scaffold`` command was to the strong parameters:

```ruby
def create
  @blog_post = BlogPost.new(blog_post_params)
  # ...
end
 ```

```ruby
def blog_post_params
  params.require(:blog_post).permit(:name, images: [])
end
```

``app/views/blog_posts/edit.html.erb``

When editing, I wanted to be able to use Ajax to remove images associated with the blog post without having to reload. I decided to put this logic in its own action:

```ruby
def destroy_image
  @image = @blog_post.images.find(params[:image_id])
  @image.destroy
  respond_to do |format|
    format.js
  end
end
```

``config/routes.rb``

```ruby
resources :blog_posts do
  member do
    delete :destroy_image
  end
end
```

### The Views

``app/views/blog_posts/_form.html.erb``

Again, Rails makes things simple. I just had to use the ``file_field`` tag. The only tricky thing was that, to allow multiple images to be uploaded at once, I had to specify ``multiple: true``.

Since this is my personal blog, I thought it was fine to leave it this way and just use ``ctrl`` or ``ctrl + shift`` to select multiple images for upload. In a user-facing form, I would implement this with JS and an "add another file" button.

```
<%= form_with(model: blog_post, local: true) do |form| %>

  <%# ... %>

  <%= form.label(:name) %><br />
  <%= form.text_field(:name) %>
  <%= form.label(:images, 'Add images to the post') %>
  <%= form.file_field(:images, multiple: true) %>

  <div class="actions">
    <%= form.submit %>
  </div>
<% end %>
```

``app/views/blog_posts/edit.html.erb``

There are three forms. (I won't copy and paste here, since it would be the same as looking at the file.) The top form specifies ``local: true`` and allows you to update the name and body text.

``app/views/blog_posts/update.js.erb``

The second specifies ``remote: true`` for clarity. (This is the default for a ``form_with``-generated form.) The Controller's ``update`` action will still be used, but again I specified ``format.js`` in the ``respond_to`` block to use server-generated JavaScript. This JavaScript:

```
document.getElementById('images-container').innerHTML = "";

// `j` is an alias for `escape_javascript`
// see : https://medium.com/backticks-tildes/unobtrusive-javascript-in-rails-c37fc757d8b1
document.getElementById('images-container').innerHTML = "<%= j render partial: 'blog_image', collection: @blog_post.images, as: :image, locals: { blog_post: @blog_post } %>";
```

...will update the images by rendering the partial with the ``collection`` option:

``app/views/blog_posts/_blog_post_image.html.erb``

```
<div id="<%= "blog-post-id-#{blog_post.id}-image-id-#{image.id}" %>">
  <p><%= image_tag(image) %></p>
  <p><%= link_to(
    "Delete image: #{image.filename}",
    destroy_image_blog_post_path(image_id: image.id),
    confirm: 'Delete image?',
    remote: true,
    method: :delete,
    )
  %></p>
</div>
```

``app/views/blog_posts/destroy_image.js.erb``

Finally, the third form makes an Ajax call to the Controller's ``destroy_image`` action, which again uses server-generated JS to remove the appropriate image from the blog post without reloading the Edit page:

```
document.getElementById('<%= "blog-post-id-#{@blog_post.id}-image-id-#{@image.id}" %>').remove();
```

``app/views/blog_posts/show.html.erb``

I won't copy and paste here. The main point of interest is the use of named captures:

```
<% if matches = element.match(/\A\!\[(?<alt_text>[a-zA-Z0-9\-_ ]*)\]\((?<image_index>\d+)\)\Z/) %>
  <div class="blog-image-div">
    <%= image_tag(@blog_post.images[matches[:image_index].to_i], alt: matches[:alt_text]) %>
  </div>
```

### Conclusion

I was able to reuse the code in these tests in my personal page to be able to add images to posts, and to add and remove images from posts while editing without the Edit page reloading or proceeding to the ``update`` action.
